#!/bin/bash

# Complete meeting recording, transcription, and summarization workflow
# This script orchestrates all three steps: record -> transcribe -> summarize

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Load config file if it exists
CONFIG_FILE="${SCRIPT_DIR}/.hushnoterc"
if [ -f "$CONFIG_FILE" ]; then
    # Source the config file
    set -a  # Export all variables
    source "$CONFIG_FILE"
    set +a
fi

OUTPUT_DIR="${RECORDINGS_DIR:-${SCRIPT_DIR}/recordings}"
WHISPER_MODEL="${WHISPER_MODEL:-base}"
OLLAMA_MODEL="${OLLAMA_MODEL:-llama3.1:8b}"
OLLAMA_URL="${OLLAMA_URL:-http://localhost:11434}"
DEBUG="${DEBUG:-false}"
PYTHON="${SCRIPT_DIR}/venv/bin/python3"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

print_usage() {
    cat << EOF
Usage: $0 [COMMAND] [OPTIONS]

Commands:
    record              Start recording a meeting
    transcribe FILE     Transcribe an audio file
    summarize FILE      Summarize a transcription
    diarize FILE        Identify speakers in an audio file
    label FILE          Label speakers with their names (interactive)
    apply-labels FILE   Apply speaker labels to create final transcript
    compress FILE       Compress WAV to MP3 and delete WAV
    clean FILE          Delete ALL audio files (WAV and MP3)
    full               Complete workflow: record, transcribe, and summarize
    process FILE        Process existing recording (transcribe + diarize + summarize)
    process-last        Process most recent recording (transcribe + diarize + summarize)
    list               List all recordings

Options:
    -d, --duration SEC  Recording duration in seconds (default: manual stop with Ctrl+C)
    -m, --model MODEL   Whisper model size: tiny, base, small, medium, large-v3 (default: base)
    -o, --ollama MODEL  Ollama model for summarization (default: llama3.1:8b)
    -f, --format FMT    Output format: txt, json, srt, vtt, md (default: txt for transcribe, md for summarize)
    -s, --speakers NUM  Number of speakers (for diarization)
    -t, --title TITLE   Meeting title (prompted if not provided)
    --diarize           Enable speaker diarization in full workflow
    --no-compress       Skip MP3 compression (keep WAV only)
    --keep-wav          Keep WAV file after compression (default: delete WAV)
    --clean             Delete ALL audio files (WAV and MP3), keep only text
    -h, --help          Show this help message

Environment Variables:
    RECORDINGS_DIR      Directory for recordings (default: ./recordings)
    WHISPER_MODEL       Default Whisper model (default: base)
    OLLAMA_MODEL        Default Ollama model (default: llama3.1:8b)
    OLLAMA_URL          Ollama API URL (default: http://localhost:11434)
    HF_TOKEN            HuggingFace API token (for speaker diarization)
    DEBUG               Enable debug output (set to 'true' to enable)

Examples:
    # Record a meeting (stop with Ctrl+C)
    $0 record

    # Record for 1 hour
    $0 record -d 3600

    # Transcribe an audio file
    $0 transcribe recordings/meeting_20251005_143022.wav

    # Complete workflow: record, transcribe, and summarize
    $0 full

    # List all recordings
    $0 list
EOF
}

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1" >&2
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1" >&2
}

log_debug() {
    if [ "$DEBUG" = "true" ]; then
        echo -e "[DEBUG] $1" >&2
    fi
}

check_dependencies() {
    local missing=()

    if ! command -v ffmpeg &> /dev/null; then
        missing+=("ffmpeg")
    fi

    if ! command -v pactl &> /dev/null; then
        missing+=("pactl (pulseaudio-utils or pipewire-pulse)")
    fi

    if ! command -v python3 &> /dev/null; then
        missing+=("python3")
    fi

    if [ ${#missing[@]} -gt 0 ]; then
        log_error "Missing dependencies: ${missing[*]}"
        exit 1
    fi
}

record_meeting() {
    local duration=""
    local output_file=""
    local title=""

    while [[ $# -gt 0 ]]; do
        case $1 in
            -d|--duration)
                duration="$2"
                shift 2
                ;;
            -o|--output)
                output_file="$2"
                shift 2
                ;;
            -t|--title)
                title="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    log_info "Starting meeting recording..."

    # Build command arguments
    local record_args=()
    [ -n "$duration" ] && record_args+=("-d" "$duration")
    [ -n "$output_file" ] && record_args+=("-o" "$output_file")
    [ -n "$title" ] && record_args+=("-t" "$title")

    # Run recording and capture output file path
    # Use temp file to avoid command substitution exit on CTRL-C
    local record_result_file="/tmp/hushnote_record_$$"
    local record_exit_code=0

    "${SCRIPT_DIR}/record_audio.sh" "${record_args[@]}" > "$record_result_file" || record_exit_code=$?

    # Read the output file path
    if [ -f "$record_result_file" ]; then
        output_file=$(cat "$record_result_file")
        rm -f "$record_result_file"
    fi

    # Debug output
    log_debug "Recording exit code: $record_exit_code"
    log_debug "Captured output_file=[$output_file]"
    log_debug "File exists check: $([ -f "$output_file" ] && echo YES || echo NO)"

    if [ -n "$output_file" ] && [ -f "$output_file" ]; then
        log_success "Recording complete: $output_file"
        echo "$output_file"
    else
        log_error "Failed to capture recording output or file doesn't exist"
        return 1
    fi
}

transcribe_meeting() {
    local audio_file="$1"
    shift

    local model="$WHISPER_MODEL"
    local format="txt"
    local output=""

    while [[ $# -gt 0 ]]; do
        case $1 in
            -m|--model)
                model="$2"
                shift 2
                ;;
            -f|--format)
                format="$2"
                shift 2
                ;;
            -o|--output)
                output="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    if [ ! -f "$audio_file" ]; then
        log_error "Audio file not found: $audio_file"
        exit 1
    fi

    log_info "Transcribing audio file: $audio_file"
    log_info "Using Whisper model: $model"

    local cmd="\"$PYTHON\" \"${SCRIPT_DIR}/transcribe.py\" \"$audio_file\" -m $model -f $format"
    [ -n "$output" ] && cmd="$cmd -o \"$output\""

    eval $cmd

    # Determine output file
    if [ -z "$output" ]; then
        output="${audio_file%.*}.${format}"
    fi

    if [ -f "$output" ]; then
        log_success "Transcription complete: $output"
        echo "$output"
    else
        log_error "Transcription output file not created: $output"
        return 1
    fi
}

summarize_meeting() {
    local transcription_file="$1"
    shift

    local model="$OLLAMA_MODEL"
    local format="md"
    local output=""

    while [[ $# -gt 0 ]]; do
        case $1 in
            -o|--ollama)
                model="$2"
                shift 2
                ;;
            -f|--format)
                format="$2"
                shift 2
                ;;
            --output)
                output="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    if [ ! -f "$transcription_file" ]; then
        log_error "Transcription file not found: $transcription_file"
        exit 1
    fi

    log_info "Summarizing transcription: $transcription_file"
    log_info "Using Ollama model: $model"

    local cmd="\"$PYTHON\" \"${SCRIPT_DIR}/summarize.py\" \"$transcription_file\" -m $model -f $format"
    [ -n "$output" ] && cmd="$cmd -o \"$output\""

    eval $cmd

    # Determine output file
    if [ -z "$output" ]; then
        local base="${transcription_file%.*}"
        output="${base}_summary.${format}"
    fi

    if [ -f "$output" ]; then
        log_success "Summary complete: $output"
        echo "$output"
    fi
}

full_workflow() {
    # Parse arguments for full workflow
    local duration=""
    local whisper_model="$WHISPER_MODEL"
    local ollama_model="$OLLAMA_MODEL"
    local format=""
    local enable_diarization=false
    local num_speakers=""
    local enable_compression=true
    local keep_wav=false
    local clean_all=false
    local title=""

    while [[ $# -gt 0 ]]; do
        case $1 in
            -d|--duration)
                duration="$2"
                shift 2
                ;;
            -m|--model)
                whisper_model="$2"
                shift 2
                ;;
            -o|--ollama)
                ollama_model="$2"
                shift 2
                ;;
            -f|--format)
                format="$2"
                shift 2
                ;;
            -t|--title)
                title="$2"
                shift 2
                ;;
            --diarize)
                enable_diarization=true
                shift
                ;;
            -s|--speakers)
                num_speakers="$2"
                shift 2
                ;;
            --no-compress)
                enable_compression=false
                shift
                ;;
            --keep-wav)
                keep_wav=true
                shift
                ;;
            --clean)
                clean_all=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    if [ "$enable_diarization" = true ]; then
        log_info "Starting full meeting workflow with speaker diarization..."
    else
        log_info "Starting full meeting workflow..."
    fi
    echo ""

    # Step 1: Record
    log_info "Step 1: Recording audio..."
    local audio_file

    # Record the audio
    # Use a temporary file to communicate the recording path
    local recording_result_file="/tmp/hushnote_recording_$$"
    local recording_exit_code=0

    # Build record_meeting arguments
    local record_args=()
    [ -n "$duration" ] && record_args+=("-d" "$duration")
    [ -n "$title" ] && record_args+=("-t" "$title")

    if [ -n "$duration" ]; then
        record_meeting "${record_args[@]}" > "$recording_result_file"
        recording_exit_code=$?
    else
        # For open-ended recording, call in a way that captures exit code but continues
        # The || true prevents set -e from exiting, then we check the actual exit code
        record_meeting "${record_args[@]}" > "$recording_result_file" || recording_exit_code=$?

        log_debug "Recording exit code: $recording_exit_code"

        # If recording was stopped (non-zero exit is expected with CTRL-C)
        if [ $recording_exit_code -ne 0 ]; then
            echo "" >&2
            log_info "Recording stopped. Continuing with processing..." >&2
            echo "" >&2
        fi
    fi

    # Read the audio file path from the result file
    if [ -f "$recording_result_file" ]; then
        audio_file=$(cat "$recording_result_file")
        rm -f "$recording_result_file"
    else
        audio_file=""
    fi

    log_debug "Audio file captured: [$audio_file]"

    if [ -z "$audio_file" ] || [ ! -f "$audio_file" ]; then
        log_error "Recording failed or no audio file was created"
        log_error "Exit code was: $recording_exit_code"
        log_error "Audio file variable: [$audio_file]"
        exit 1
    fi

    echo ""

    if [ "$enable_diarization" = true ]; then
        # Diarization workflow: 7 steps

        # Step 2: Diarize
        log_info "Step 2: Identifying speakers..."
        local speakers_file
        if [ -n "$num_speakers" ]; then
            speakers_file=$(diarize_meeting "$audio_file" -s "$num_speakers")
        else
            speakers_file=$(diarize_meeting "$audio_file")
        fi

        if [ -z "$speakers_file" ] || [ ! -f "$speakers_file" ]; then
            log_error "Diarization failed"
            exit 1
        fi

        echo ""

        # Step 3: Transcribe (as JSON for merging)
        log_info "Step 3: Transcribing audio..."
        local base="${audio_file%.*}"
        local transcription_json="${base}.json"

        "$PYTHON" "${SCRIPT_DIR}/transcribe.py" "$audio_file" -m "$whisper_model" -f json -o "$transcription_json"

        if [ ! -f "$transcription_json" ]; then
            log_error "Transcription failed"
            exit 1
        fi

        echo ""

        # Step 4: Merge diarization + transcription
        log_info "Step 4: Merging speaker info with transcription..."
        local diarized_file="${base}_diarized.json"

        "$PYTHON" "${SCRIPT_DIR}/merge_diarization.py" "$speakers_file" "$transcription_json" -o "$diarized_file"

        if [ ! -f "$diarized_file" ]; then
            log_error "Merge failed"
            exit 1
        fi

        echo ""

        # Step 5: Label speakers interactively
        log_info "Step 5: Label speakers with their names..."
        echo ""

        # Call label_speakers without command substitution to allow interactive input
        label_speakers "$diarized_file"

        # Determine output file manually
        local base="${diarized_file%_diarized.json}"
        local labeled_file="${base}_speakers_labeled.json"

        if [ ! -f "$labeled_file" ]; then
            log_error "Labeling failed"
            exit 1
        fi

        echo ""

        # Step 6: Apply labels to create final transcript
        log_info "Step 6: Creating final transcript with speaker names..."
        local transcription_file=$(apply_speaker_labels "$labeled_file" -f txt)

        if [ -z "$transcription_file" ] || [ ! -f "$transcription_file" ]; then
            log_error "Apply labels failed"
            exit 1
        fi

        echo ""

        # Step 7: Summarize
        log_info "Step 7: Generating summary..."
        local summary_file
        if [ -n "$ollama_model" ]; then
            summary_file=$(summarize_meeting "$transcription_file" -o "$ollama_model")
        else
            summary_file=$(summarize_meeting "$transcription_file")
        fi

        if [ -z "$summary_file" ] || [ ! -f "$summary_file" ]; then
            log_error "Summarization failed"
            exit 1
        fi

        echo ""

        # Step 8: Compress audio and cleanup
        if [ "$clean_all" = true ]; then
            log_info "Step 8: Removing all audio files..."
            # Delete both WAV and MP3 if they exist
            [ -f "$audio_file" ] && rm "$audio_file" && log_success "Deleted: $audio_file"
            local mp3_file="${audio_file%.wav}.mp3"
            [ -f "$mp3_file" ] && rm "$mp3_file" && log_success "Deleted: $mp3_file"
            audio_file="(deleted)"
            echo ""
        elif [ "$enable_compression" = true ]; then
            log_info "Step 8: Compressing audio to MP3..."
            local mp3_file
            if [ "$keep_wav" = true ]; then
                mp3_file=$(compress_audio "$audio_file")
            else
                # Default: delete WAV after compression
                mp3_file=$(compress_audio "$audio_file" --delete-wav)
            fi

            if [ -n "$mp3_file" ] && [ -f "$mp3_file" ]; then
                audio_file="$mp3_file"
            fi
            echo ""
        fi

        log_success "Complete workflow with diarization finished!"
        echo ""
        echo "Files generated:"
        echo "  Audio:          $audio_file"
        echo "  Diarization:    $speakers_file"
        echo "  Labeled:        $labeled_file"
        echo "  Transcription:  $transcription_file"
        echo "  Summary:        $summary_file"
    else
        # Standard workflow without diarization: 3 steps

        # Step 2: Transcribe
        log_info "Step 2/3: Transcribing audio..."
        local transcription_file
        if [ -n "$whisper_model" ]; then
            transcription_file=$(transcribe_meeting "$audio_file" -m "$whisper_model" 2>&1 | tail -1)
        else
            transcription_file=$(transcribe_meeting "$audio_file" 2>&1 | tail -1)
        fi

        log_debug "Transcription file captured: [$transcription_file]"

        if [ -z "$transcription_file" ] || [ ! -f "$transcription_file" ]; then
            log_error "Transcription failed - file not found: $transcription_file"
            exit 1
        fi

        echo ""

        # Step 3: Summarize
        log_info "Step 3/3: Generating summary..."
        local summary_file
        if [ -n "$ollama_model" ]; then
            summary_file=$(summarize_meeting "$transcription_file" -o "$ollama_model")
        else
            summary_file=$(summarize_meeting "$transcription_file")
        fi

        if [ -z "$summary_file" ] || [ ! -f "$summary_file" ]; then
            log_error "Summarization failed"
            exit 1
        fi

        echo ""

        # Step 4: Compress audio and cleanup
        if [ "$clean_all" = true ]; then
            log_info "Step 4/4: Removing all audio files..."
            # Delete both WAV and MP3 if they exist
            [ -f "$audio_file" ] && rm "$audio_file" && log_success "Deleted: $audio_file"
            local mp3_file="${audio_file%.wav}.mp3"
            [ -f "$mp3_file" ] && rm "$mp3_file" && log_success "Deleted: $mp3_file"
            audio_file="(deleted)"
            echo ""
        elif [ "$enable_compression" = true ]; then
            log_info "Step 4/4: Compressing audio to MP3..."
            local mp3_file
            if [ "$keep_wav" = true ]; then
                mp3_file=$(compress_audio "$audio_file")
            else
                # Default: delete WAV after compression
                mp3_file=$(compress_audio "$audio_file" --delete-wav)
            fi

            if [ -n "$mp3_file" ] && [ -f "$mp3_file" ]; then
                audio_file="$mp3_file"
            fi
            echo ""
        fi

        log_success "Complete workflow finished!"
        echo ""
        echo "Files generated:"
        echo "  Audio:          $audio_file"
        echo "  Transcription:  $transcription_file"
        echo "  Summary:        $summary_file"
    fi
}

diarize_meeting() {
    local audio_file="$1"
    shift

    local speakers=""

    while [[ $# -gt 0 ]]; do
        case $1 in
            -s|--speakers)
                speakers="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    if [ ! -f "$audio_file" ]; then
        log_error "Audio file not found: $audio_file"
        exit 1
    fi

    log_info "Identifying speakers in: $audio_file"

    local cmd="\"$PYTHON\" \"${SCRIPT_DIR}/diarize.py\" \"$audio_file\""
    [ -n "$speakers" ] && cmd="$cmd -s $speakers"

    eval $cmd

    # Determine output file
    local base="${audio_file%.*}"
    local output="${base}_speakers.json"

    if [ -f "$output" ]; then
        log_success "Diarization complete: $output"
        echo "$output"
    fi
}

label_speakers() {
    local diarized_file="$1"
    shift

    if [ ! -f "$diarized_file" ]; then
        log_error "Diarized file not found: $diarized_file"
        exit 1
    fi

    log_info "Labeling speakers in: $diarized_file"
    echo ""

    # Run label.py interactively (don't capture output)
    "$PYTHON" "${SCRIPT_DIR}/label.py" "$diarized_file" </dev/tty

    # Determine output file
    local base="${diarized_file%_diarized.json}"
    local output="${base}_speakers_labeled.json"

    if [ -f "$output" ]; then
        echo ""
        log_success "Labeling complete: $output"
        echo "$output"
    fi
}

apply_speaker_labels() {
    local labeled_file="$1"
    shift

    local format="txt"
    local output=""

    while [[ $# -gt 0 ]]; do
        case $1 in
            -f|--format)
                format="$2"
                shift 2
                ;;
            -o|--output)
                output="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    if [ ! -f "$labeled_file" ]; then
        log_error "Labeled file not found: $labeled_file"
        exit 1
    fi

    log_info "Applying labels to transcript: $labeled_file"

    local cmd="\"$PYTHON\" \"${SCRIPT_DIR}/apply_labels.py\" \"$labeled_file\" -f $format"
    [ -n "$output" ] && cmd="$cmd -o \"$output\""

    eval $cmd

    # Determine output file
    if [ -z "$output" ]; then
        # Extract base name from labeled file
        local base=$(basename "$labeled_file" "_speakers_labeled.json")
        base="${base%.json}"
        output="$(dirname "$labeled_file")/${base}.${format}"
    fi

    if [ -f "$output" ]; then
        log_success "Transcript complete: $output"
        echo "$output"
    fi
}

compress_audio() {
    local audio_file="$1"
    shift

    local delete_wav=false

    while [[ $# -gt 0 ]]; do
        case $1 in
            --delete-wav|--clean)
                delete_wav=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    if [ ! -f "$audio_file" ]; then
        log_error "Audio file not found: $audio_file"
        exit 1
    fi

    log_info "Compressing audio: $audio_file"

    local cmd="\"${SCRIPT_DIR}/compress.sh\" \"$audio_file\""
    [ "$delete_wav" = true ] && cmd="$cmd --delete-wav"

    local mp3_file=$(eval $cmd)

    if [ -n "$mp3_file" ] && [ -f "$mp3_file" ]; then
        log_success "Compression complete: $mp3_file"
        echo "$mp3_file"
    fi
}

clean_audio() {
    local audio_file="$1"

    # Determine base path and possible audio files
    local base_path="${audio_file%.wav}"
    base_path="${base_path%.mp3}"
    local wav_file="${base_path}.wav"
    local mp3_file="${base_path}.mp3"

    local deleted_count=0

    log_info "Removing all audio files for: $(basename "$base_path")"

    # Delete WAV if exists
    if [ -f "$wav_file" ]; then
        rm "$wav_file"
        log_success "Deleted: $wav_file"
        deleted_count=$((deleted_count + 1))
    fi

    # Delete MP3 if exists
    if [ -f "$mp3_file" ]; then
        rm "$mp3_file"
        log_success "Deleted: $mp3_file"
        deleted_count=$((deleted_count + 1))
    fi

    if [ $deleted_count -eq 0 ]; then
        log_warn "No audio files found to delete"
        exit 1
    fi

    log_info "Text files (transcripts, summaries) preserved"
}

list_recordings() {
    log_info "Recordings in $OUTPUT_DIR:"
    echo ""

    if [ ! -d "$OUTPUT_DIR" ] || [ -z "$(ls -A "$OUTPUT_DIR" 2>/dev/null)" ]; then
        log_warn "No recordings found"
        exit 0
    fi

    local count=0
    # Iterate through date directories (YYYYMMDD format)
    for date_dir in "$OUTPUT_DIR"/[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]; do
        if [ ! -d "$date_dir" ]; then
            continue
        fi

        local date_name=$(basename "$date_dir")
        local formatted_date="${date_name:0:4}-${date_name:4:2}-${date_name:6:2}"

        # Iterate through meeting directories within each date
        for meeting_dir in "$date_dir"/meeting_*; do
            if [ ! -d "$meeting_dir" ]; then
                continue
            fi

            # Find the .wav file in the meeting directory
            local wav_file=$(find "$meeting_dir" -name "*.wav" -type f | head -1)
            if [ -z "$wav_file" ] || [ ! -f "$wav_file" ]; then
                continue
            fi

            count=$((count + 1))
            local size=$(du -h "$wav_file" | cut -f1)
            local timestamp=$(stat -c %y "$wav_file" | cut -d' ' -f1,2 | cut -d'.' -f1)
            local meeting_name=$(basename "$meeting_dir")

            # Try to load title from metadata file
            local base="${wav_file%.*}"
            local metadata_file="${base}_metadata.json"
            local title=""
            if [ -f "$metadata_file" ]; then
                title=$(grep -o '"title"[[:space:]]*:[[:space:]]*"[^"]*"' "$metadata_file" | sed 's/"title"[[:space:]]*:[[:space:]]*"\([^"]*\)"/\1/')
            fi

            if [ -n "$title" ]; then
                echo "$count. $formatted_date - $title"
            else
                echo "$count. $formatted_date - $(basename "$meeting_name")"
            fi
            echo "   Path: $meeting_dir"
            echo "   Size: $size | Date: $timestamp"

            # Check for associated files
            [ -f "${base}.txt" ] && echo "   ✓ Transcription available"
            [ -f "${base}_speakers.json" ] && echo "   ✓ Diarization available"
            [ -f "${base}_summary.md" ] && echo "   ✓ Summary available"
            echo ""
        done
    done

    if [ $count -eq 0 ]; then
        log_warn "No recordings found"
    fi
}

# Main command dispatcher
main() {
    if [ $# -eq 0 ]; then
        print_usage
        exit 0
    fi

    check_dependencies

    local command="$1"
    shift

    case "$command" in
        record)
            record_meeting "$@"
            ;;
        transcribe)
            if [ $# -eq 0 ]; then
                log_error "Missing audio file argument"
                echo "Usage: $0 transcribe FILE [OPTIONS]"
                exit 1
            fi
            transcribe_meeting "$@"
            ;;
        summarize)
            if [ $# -eq 0 ]; then
                log_error "Missing transcription file argument"
                echo "Usage: $0 summarize FILE [OPTIONS]"
                exit 1
            fi
            summarize_meeting "$@"
            ;;
        diarize)
            if [ $# -eq 0 ]; then
                log_error "Missing audio file argument"
                echo "Usage: $0 diarize FILE [OPTIONS]"
                exit 1
            fi
            diarize_meeting "$@"
            ;;
        label)
            if [ $# -eq 0 ]; then
                log_error "Missing diarized file argument"
                echo "Usage: $0 label FILE"
                exit 1
            fi
            label_speakers "$@"
            ;;
        apply-labels)
            if [ $# -eq 0 ]; then
                log_error "Missing labeled file argument"
                echo "Usage: $0 apply-labels FILE [OPTIONS]"
                exit 1
            fi
            apply_speaker_labels "$@"
            ;;
        compress)
            if [ $# -eq 0 ]; then
                log_error "Missing audio file argument"
                echo "Usage: $0 compress FILE"
                echo ""
                echo "Compress WAV to MP3 and delete WAV (default workflow behavior)"
                exit 1
            fi
            compress_audio "$1" --delete-wav
            ;;
        clean)
            if [ $# -eq 0 ]; then
                log_error "Missing audio file argument"
                echo "Usage: $0 clean FILE"
                echo ""
                echo "Delete ALL audio files (WAV and MP3), keep only text/transcripts"
                exit 1
            fi
            clean_audio "$@"
            ;;
        process)
            if [ $# -eq 0 ] || [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
                echo "Usage: $0 process FILE [OPTIONS]"
                echo ""
                echo "Process an existing recording (transcribe + optional diarize + summarize)"
                echo ""
                echo "Options:"
                echo "  -m, --model MODEL   Whisper model (tiny|base|small|medium|large-v3)"
                echo "  -o, --ollama MODEL  Ollama model for summarization"
                echo "  -s, --speakers NUM  Number of speakers (requires --diarize)"
                echo "  --diarize           Enable speaker diarization"
                echo ""
                echo "Examples:"
                echo "  # Simple processing (transcribe + summarize)"
                echo "  $0 process recordings/meeting.wav -m tiny"
                echo ""
                echo "  # With speaker diarization"
                echo "  $0 process recordings/meeting.wav --diarize --speakers 2 -m small"
                exit 0
            fi

            local audio_file="$1"
            shift

            if [ ! -f "$audio_file" ]; then
                log_error "Audio file not found: $audio_file"
                exit 1
            fi

            # Parse arguments
            local whisper_model="$WHISPER_MODEL"
            local ollama_model="$OLLAMA_MODEL"
            local enable_diarization=false
            local num_speakers=""
            local enable_compression=true
            local keep_wav=false
            local clean_all=false

            while [[ $# -gt 0 ]]; do
                case $1 in
                    -m|--model)
                        whisper_model="$2"
                        shift 2
                        ;;
                    -o|--ollama)
                        ollama_model="$2"
                        shift 2
                        ;;
                    --diarize)
                        enable_diarization=true
                        shift
                        ;;
                    -s|--speakers)
                        num_speakers="$2"
                        shift 2
                        ;;
                    --no-compress)
                        enable_compression=false
                        shift
                        ;;
                    --keep-wav)
                        keep_wav=true
                        shift
                        ;;
                    --clean)
                        clean_all=true
                        shift
                        ;;
                    *)
                        shift
                        ;;
                esac
            done

            if [ "$enable_diarization" = true ]; then
                log_info "Processing recording with diarization: $audio_file"
                echo ""

                # Step 1: Diarize
                log_info "Step 1: Identifying speakers..."
                local speakers_file
                if [ -n "$num_speakers" ]; then
                    speakers_file=$(diarize_meeting "$audio_file" -s "$num_speakers")
                else
                    speakers_file=$(diarize_meeting "$audio_file")
                fi

                if [ -z "$speakers_file" ] || [ ! -f "$speakers_file" ]; then
                    log_error "Diarization failed"
                    exit 1
                fi
                echo ""

                # Step 2: Transcribe
                log_info "Step 2: Transcribing audio..."
                local base="${audio_file%.*}"
                local transcription_json="${base}.json"

                "$PYTHON" "${SCRIPT_DIR}/transcribe.py" "$audio_file" -m "$whisper_model" -f json -o "$transcription_json"

                if [ ! -f "$transcription_json" ]; then
                    log_error "Transcription failed"
                    exit 1
                fi
                echo ""

                # Step 3: Merge
                log_info "Step 3: Merging speaker info with transcription..."
                local diarized_file="${base}_diarized.json"

                "$PYTHON" "${SCRIPT_DIR}/merge_diarization.py" "$speakers_file" "$transcription_json" -o "$diarized_file"

                if [ ! -f "$diarized_file" ]; then
                    log_error "Merge failed"
                    exit 1
                fi
                echo ""

                # Step 4: Label speakers
                log_info "Step 4: Label speakers with their names..."
                echo ""

                # Call label_speakers without command substitution to allow interactive input
                label_speakers "$diarized_file"

                # Determine output file manually
                local base="${diarized_file%_diarized.json}"
                local labeled_file="${base}_speakers_labeled.json"

                if [ ! -f "$labeled_file" ]; then
                    log_error "Labeling failed"
                    exit 1
                fi
                echo ""

                # Step 5: Apply labels
                log_info "Step 5: Creating final transcript with speaker names..."
                local transcription_file=$(apply_speaker_labels "$labeled_file" -f txt)

                if [ -z "$transcription_file" ] || [ ! -f "$transcription_file" ]; then
                    log_error "Apply labels failed"
                    exit 1
                fi
                echo ""

                # Step 6: Summarize
                log_info "Step 6: Generating summary..."
                local summary_file
                if [ -n "$ollama_model" ]; then
                    summary_file=$(summarize_meeting "$transcription_file" -o "$ollama_model")
                else
                    summary_file=$(summarize_meeting "$transcription_file")
                fi

                if [ -z "$summary_file" ] || [ ! -f "$summary_file" ]; then
                    log_error "Summarization failed"
                    exit 1
                fi

                echo ""

                # Step 7: Compress audio and cleanup
                if [ "$clean_all" = true ]; then
                    log_info "Step 7: Removing all audio files..."
                    [ -f "$audio_file" ] && rm "$audio_file" && log_success "Deleted: $audio_file"
                    local mp3_file="${audio_file%.wav}.mp3"
                    [ -f "$mp3_file" ] && rm "$mp3_file" && log_success "Deleted: $mp3_file"
                    audio_file="(deleted)"
                    echo ""
                elif [ "$enable_compression" = true ]; then
                    log_info "Step 7: Compressing audio to MP3..."
                    local mp3_file
                    if [ "$keep_wav" = true ]; then
                        mp3_file=$(compress_audio "$audio_file")
                    else
                        mp3_file=$(compress_audio "$audio_file" --delete-wav)
                    fi

                    if [ -n "$mp3_file" ] && [ -f "$mp3_file" ]; then
                        audio_file="$mp3_file"
                    fi
                    echo ""
                fi

                log_success "Processing complete with diarization!"
                echo ""
                echo "Files generated:"
                echo "  Audio:          $audio_file"
                echo "  Diarization:    $speakers_file"
                echo "  Labeled:        $labeled_file"
                echo "  Transcription:  $transcription_file"
                echo "  Summary:        $summary_file"
            else
                # Simple transcribe + summarize workflow
                log_info "Processing recording: $audio_file"
                echo ""

                local transcription_file=$(transcribe_meeting "$audio_file" -m "$whisper_model")

                if [ -f "$transcription_file" ]; then
                    local summary_file
                    if [ -n "$ollama_model" ]; then
                        summary_file=$(summarize_meeting "$transcription_file" -o "$ollama_model")
                    else
                        summary_file=$(summarize_meeting "$transcription_file")
                    fi

                    echo ""

                    # Compress audio and cleanup
                    if [ "$clean_all" = true ]; then
                        echo ""
                        log_info "Removing all audio files..."
                        [ -f "$audio_file" ] && rm "$audio_file" && log_success "Deleted: $audio_file"
                        local mp3_file="${audio_file%.wav}.mp3"
                        [ -f "$mp3_file" ] && rm "$mp3_file" && log_success "Deleted: $mp3_file"
                        audio_file="(deleted)"
                    elif [ "$enable_compression" = true ]; then
                        echo ""
                        log_info "Compressing audio to MP3..."
                        local mp3_file
                        if [ "$keep_wav" = true ]; then
                            mp3_file=$(compress_audio "$audio_file")
                        else
                            mp3_file=$(compress_audio "$audio_file" --delete-wav)
                        fi

                        if [ -n "$mp3_file" ] && [ -f "$mp3_file" ]; then
                            audio_file="$mp3_file"
                        fi
                    fi

                    echo ""
                    log_success "Processing complete!"
                    echo ""
                    echo "Files generated:"
                    echo "  Audio:          $audio_file"
                    echo "  Transcription:  $transcription_file"
                    echo "  Summary:        $summary_file"
                fi
            fi
            ;;
        process-last)
            # Find most recent recording in date/meeting subdirectories
            local latest_recording=""
            local latest_time=0

            # Search through all date directories and meeting subdirectories
            for date_dir in "$OUTPUT_DIR"/[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]; do
                if [ ! -d "$date_dir" ]; then
                    continue
                fi

                for meeting_dir in "$date_dir"/meeting_*; do
                    if [ ! -d "$meeting_dir" ]; then
                        continue
                    fi

                    # Find .wav file in meeting directory
                    local wav_file=$(find "$meeting_dir" -name "*.wav" -type f | head -1)
                    if [ -n "$wav_file" ] && [ -f "$wav_file" ]; then
                        local file_time=$(stat -c %Y "$wav_file" 2>/dev/null || echo 0)
                        if [ "$file_time" -gt "$latest_time" ]; then
                            latest_time=$file_time
                            latest_recording="$wav_file"
                        fi
                    fi
                done
            done

            if [ -z "$latest_recording" ]; then
                log_error "No recordings found in $OUTPUT_DIR"
                exit 1
            fi

            log_info "Processing most recent recording: $(basename "$(dirname "$latest_recording")")/$(basename "$latest_recording")"

            # Call process command with the latest recording
            "$0" process "$latest_recording" "$@"
            ;;
        full)
            full_workflow "$@"
            ;;
        list)
            list_recordings
            ;;
        -h|--help)
            print_usage
            ;;
        *)
            log_error "Unknown command: $command"
            echo ""
            print_usage
            exit 1
            ;;
    esac
}

main "$@"
